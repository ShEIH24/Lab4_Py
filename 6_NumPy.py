"""
С помощью модуля numPy реализуйте следующие операции: 1)
умножение произвольных матриц А (размерности 3х5) и В (5х2); 2)
умножение матрицы (5х3) на трехмерный вектор; 3) решение
произвольной системы линейных уравнений; 4) расчет определителя
матрицы; 5) получение обратной и транспонированной матриц.
Также продемонстрируйте на примере матрицы 5х5 тот факт, что
определитель равен произведению собственных значений матрицы.
"""
import numpy as np
np.set_printoptions(precision=4, suppress=True)  # Для более компактного вывода

print("1) Умножение произвольных матриц A (3x5) и B (5x2)")
# Создаем произвольные матрицы с помощью генератора случайных чисел
A = np.random.rand(3, 5)
B = np.random.rand(5, 2)

print("Матрица A (3x5):")
print(A)
print("\nМатрица B (5x2):")
print(B)

# Умножение матриц
C = np.dot(A, B)  # или C = A @ B (оператор матричного умножения в Python 3.5+)
print("\nРезультат умножения A*B (3x2):")
print(C)

print("\n" + "="*50)

print("2) Умножение матрицы (5x3) на трехмерный вектор")
# Создаем произвольную матрицу 5x3
D = np.random.rand(5, 3)
# Создаем произвольный вектор размерности 3
v = np.random.rand(3)

print("Матрица D (5x3):")
print(D)
print("\nВектор v (3):")
print(v)

# Умножение матрицы на вектор
result = np.dot(D, v)  # или result = D @ v
print("\nРезультат умножения D*v (5):")
print(result)

print("\n" + "="*50)

print("3) Решение произвольной системы линейных уравнений")
# Создаем случайную матрицу коэффициентов
n = 3  # размерность системы
E = np.random.rand(n, n)
# Создаем случайный вектор правой части
b = np.random.rand(n)

print("Матрица коэффициентов E:")
print(E)
print("\nВектор правой части b:")
print(b)

# Решение системы уравнений E*x = b
x = np.linalg.solve(E, b)
print("\nРешение системы E*x = b:")
print(x)

# Проверка решения
print("\nПроверка E*x ≈ b:")
print(np.dot(E, x))

print("\n" + "="*50)

print("4) Расчет определителя матрицы")
# Используем ранее созданную матрицу E
det_E = np.linalg.det(E)
print("Определитель матрицы E:")
print(det_E)

print("\n" + "="*50)

print("5) Получение обратной и транспонированной матриц")
# Обратная матрица
E_inv = np.linalg.inv(E)
print("Обратная матрица E^(-1):")
print(E_inv)

# Проверка, что E * E^(-1) ≈ I (единичная матрица)
print("\nПроверка E * E^(-1) ≈ I:")
print(np.dot(E, E_inv))

# Транспонированная матрица
E_trans = E.T  # или np.transpose(E)
print("\nТранспонированная матрица E^T:")
print(E_trans)

print("\n" + "="*50)

print("6) Демонстрация того, что определитель равен произведению собственных значений")
# Создаем случайную матрицу 5x5
F = np.random.rand(5, 5)
print("Матрица F (5x5):")
print(F)

# Вычисляем определитель
det_F = np.linalg.det(F)
print("\nОпределитель матрицы F:")
print(det_F)

# Вычисляем собственные значения
eigenvalues = np.linalg.eigvals(F)
print("\nСобственные значения матрицы F:")
print(eigenvalues)

# Вычисляем произведение собственных значений
product_eigenvalues = np.prod(eigenvalues)
print("\nПроизведение собственных значений:")
print(product_eigenvalues)

print("\nРазница между определителем и произведением собственных значений:")
print(np.abs(det_F - product_eigenvalues))
print("(Должна быть близка к нулю в пределах вычислительной погрешности)")
